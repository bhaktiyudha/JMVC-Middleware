package utilities

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"runtime"
	"sync"
	"time"

	client "github.com/influxdata/influxdb1-client/v2"
)

// These flags define which text to prefix to each log entry generated by the CustomLogger.
// Bits are or'ed together to control what's printed.
// There is no control over the order they appear (the order listed
// here) or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate          = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                          // the time in the local time zone: 01:23:23
	Lmicroseconds                  // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                      // full file name and line number: /a/b/c/d.go:23
	Lshortfile                     // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                           // if Ldate or Ltime is set, use UTC rather than the local time zone
	LstdFlags      = Ldate | Ltime // initial values for the standard logger
	TRACE_PREFIX   = "TRACE: "
	INFO_PREFIX    = "INFO: "
	WARNING_PREFIX = "WARNING: "
	ERROR_PREFIX   = "ERROR: "
)

// A CustomLogger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer's Write method. A CustomLogger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type CustomLogger struct {
	mu      sync.Mutex    // ensures atomic writes; protects the following fields
	prefix  string        // prefix to write at beginning of each line
	flag    int           // properties
	out     io.Writer     // destination for output
	buf     []byte        // for accumulating text to write
	cInflux client.Client // influxdb client connection
}

var (
	Trace              *CustomLogger
	Info               *CustomLogger
	Warning            *CustomLogger
	Error              *CustomLogger
	influxAddress      = ""
	influxPort         = ""
	influxUsername     = ""
	influxPassword     = ""
	influxDatabaseName = ""
	host               = "localhost"
	hostname           = "local"
	appname            = "Test"
	dunno              = []byte("???")
	centerDot          = []byte("·")
	dot                = []byte(".")
	slash              = []byte("/")
)

func queryDB(cmd string, cInflux client.Client) ([]client.Result, error) {
	q := client.Query{
		Command:  cmd,
		Database: influxDatabaseName,
	}

	var res []client.Result

	if response, err := cInflux.Query(q); err == nil {
		if response.Error() != nil {
			return res, response.Error()
		}
		res = response.Results
	} else {
		return res, err
	}
	return res, nil
}

func init() {
	var (
		cInflux client.Client
		err     error
	)

	if os.Getenv("Enable_Logs_To_Influx") == "true" {
		if os.Getenv("Logs_InfluxDB_Name") != "" {
			influxDatabaseName = os.Getenv("Logs_InfluxDB_Name")
		}

		if os.Getenv("Logs_InfluxDB_Username") != "" {
			influxUsername = os.Getenv("Logs_InfluxDB_Username")
		}

		if os.Getenv("Logs_InfluxDB_Password") != "" {
			influxPassword = os.Getenv("Logs_InfluxDB_Password")
		}

		if os.Getenv("Logs_InfluxDB_Address") != "" {
			influxAddress = os.Getenv("Logs_InfluxDB_Address")
		}

		if os.Getenv("Logs_InfluxDB_Port") != "" {
			influxPort = os.Getenv("Logs_InfluxDB_Port")
		}

		if os.Getenv("Logs_Host") != "" {
			host = os.Getenv("Logs_Host")
		}

		if os.Getenv("Logs_Hostname") != "" {
			hostname = os.Getenv("Logs_Hostname")
		}

		if os.Getenv("Logs_Appname") != "" {
			appname = os.Getenv("Logs_Appname")
		}

		cInflux, err = client.NewHTTPClient(client.HTTPConfig{
			Addr:     influxAddress + ":" + influxPort,
			Username: influxUsername,
			Password: influxPassword,
		})

		if err == nil {
			_, _, err = cInflux.Ping(time.Second * 3)
		}

		if err != nil {
			Fatalf("Error connect to influxdb : %s", err)
		}

		_, err = queryDB(fmt.Sprintf("CREATE DATABASE %s", influxDatabaseName), cInflux)

		if err != nil {
			Fatalf("Error creating database influxdb : %s", err)
		}
	}

	var traceHandle io.Writer = ioutil.Discard
	var infoHandle io.Writer = os.Stdout
	var warningHandle io.Writer = os.Stdout
	var errorHandle io.Writer = os.Stderr

	if os.Getenv("IS_PRODUCTION") == "true" {
		infoHandle = ioutil.Discard
	}

	Trace = NewCustomLogger(cInflux, traceHandle,
		TRACE_PREFIX,
		Ldate|Ltime|Llongfile)

	Info = NewCustomLogger(cInflux, infoHandle,
		INFO_PREFIX,
		Ldate|Ltime|Llongfile)

	Warning = NewCustomLogger(cInflux, warningHandle,
		WARNING_PREFIX,
		Ldate|Ltime|Llongfile)

	Error = NewCustomLogger(cInflux, errorHandle,
		ERROR_PREFIX,
		Ldate|Ltime|Llongfile)
}

// source returns a space-trimmed slice of the n'th line.
func source(lines [][]byte, n int) []byte {
	n-- // in stack trace, lines are 1-indexed but our array is 0-indexed
	if n < 0 || n >= len(lines) {
		return dunno
	}
	return bytes.TrimSpace(lines[n])
}

// function returns, if possible, the name of the function containing the PC.
func function(pc uintptr) []byte {
	fn := runtime.FuncForPC(pc)
	if fn == nil {
		return dunno
	}
	name := []byte(fn.Name())
	// The name includes the path name to the package, which is unnecessary
	// since the file name is already included.  Plus, it has center dots.
	// That is, we see
	//	runtime/debug.*T·ptrmethod
	// and want
	//	*T.ptrmethod
	// Also the package path might contains dot (e.g. code.google.com/...),
	// so first eliminate the path prefix
	if lastSlash := bytes.LastIndex(name, slash); lastSlash >= 0 {
		name = name[lastSlash+1:]
	}
	if period := bytes.Index(name, dot); period >= 0 {
		name = name[period+1:]
	}
	name = bytes.Replace(name, centerDot, dot, -1)
	return name
}

// Stack returns a nicely formatted Stack frame, skipping skip frames.
func Stack(skip int) []byte {
	buf := new(bytes.Buffer) // the returned data
	// As we loop, we open files and read them. These variables record the currently
	// loaded file.
	var lines [][]byte
	var lastFile string
	for i := skip; ; i++ { // Skip the expected number of frames
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			break
		}
		// Print this much at least.  If we can't find the source, it won't show.
		fmt.Fprintf(buf, "%s:%d (0x%x)\n", file, line, pc)
		if file != lastFile {
			data, err := ioutil.ReadFile(file)
			if err != nil {
				continue
			}
			lines = bytes.Split(data, []byte{'\n'})
			lastFile = file
		}
		fmt.Fprintf(buf, "\t%s: %s\n", function(pc), source(lines, line))
	}
	return buf.Bytes()
}

// NewCustomLogger creates a new CustomLogger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
func NewCustomLogger(cIfnlux client.Client, out io.Writer, prefix string, flag int) *CustomLogger {
	return &CustomLogger{out: out, prefix: prefix, flag: flag, cInflux: cIfnlux}
}

// SetOutput sets the output destination for the logger.
func (l *CustomLogger) SetOutput(w io.Writer) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.out = w
}

var std = NewCustomLogger(nil, os.Stderr, "", LstdFlags)

// Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
func itoa(buf *[]byte, i int, wid int) {
	// Assemble decimal in reverse order.
	var b [20]byte
	bp := len(b) - 1
	for i >= 10 || wid > 1 {
		wid--
		q := i / 10
		b[bp] = byte('0' + i - q*10)
		bp--
		i = q
	}
	// i < 10
	b[bp] = byte('0' + i)
	*buf = append(*buf, b[bp:]...)
}

// formatHeader writes log header to buf in following order:
//   * l.prefix (if it's not blank),
//   * date and/or time (if corresponding flags are provided),
//   * file and line number (if corresponding flags are provided).
func (l *CustomLogger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
	*buf = append(*buf, l.prefix...)
	if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
		if l.flag&LUTC != 0 {
			t = t.UTC()
		}
		if l.flag&Ldate != 0 {
			year, month, day := t.Date()
			itoa(buf, year, 4)
			*buf = append(*buf, '/')
			itoa(buf, int(month), 2)
			*buf = append(*buf, '/')
			itoa(buf, day, 2)
			*buf = append(*buf, ' ')
		}
		if l.flag&(Ltime|Lmicroseconds) != 0 {
			hour, min, sec := t.Clock()
			itoa(buf, hour, 2)
			*buf = append(*buf, ':')
			itoa(buf, min, 2)
			*buf = append(*buf, ':')
			itoa(buf, sec, 2)
			if l.flag&Lmicroseconds != 0 {
				*buf = append(*buf, '.')
				itoa(buf, t.Nanosecond()/1e3, 6)
			}
			*buf = append(*buf, ' ')
		}
	}
	if l.flag&(Lshortfile|Llongfile) != 0 {
		if l.flag&Lshortfile != 0 {
			short := file
			for i := len(file) - 1; i > 0; i-- {
				if file[i] == '/' {
					short = file[i+1:]
					break
				}
			}
			file = short
		}
		*buf = append(*buf, file...)
		*buf = append(*buf, ':')
		itoa(buf, line, -1)
		*buf = append(*buf, ": "...)
	}
}

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// CustomLogger. A newline is appended if the last character of s is not
// already a newline. Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
func (l *CustomLogger) Output(calldepth int, s string) error {
	now := time.Now() // get this early.
	var file string
	var line int
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.flag&(Lshortfile|Llongfile) != 0 {
		// Release lock while getting caller info - it's expensive.
		l.mu.Unlock()
		var ok bool
		_, file, line, ok = runtime.Caller(calldepth)
		if !ok {
			file = "???"
			line = 0
		}
		l.mu.Lock()
	}
	l.buf = l.buf[:0]
	l.formatHeader(&l.buf, now, file, line)
	l.buf = append(l.buf, s...)
	if len(s) == 0 || s[len(s)-1] != '\n' {
		l.buf = append(l.buf, '\n')
	}

	//save to influx if save logs to influx is enabled and if its prefix is info
	//then it only save to influx if env IS_PRODUCTION is not true
	if l.cInflux != nil && (l.prefix != INFO_PREFIX || (l.prefix == INFO_PREFIX && os.Getenv("IS_PRODUCTION") != "true")) {
		severity := ""
		severityCode := 0

		if l.prefix == INFO_PREFIX {
			severity = "info"
			severityCode = 6
		} else if l.prefix == WARNING_PREFIX {
			severity = "warning"
			severityCode = 4
		} else if l.prefix == TRACE_PREFIX {
			severity = "debug"
			severityCode = 7
		} else {
			severity = "err"
			severityCode = 3
		}

		bp, _ := client.NewBatchPoints(client.BatchPointsConfig{
			Database:  influxDatabaseName,
			Precision: "ns",
		})

		pt, err := client.NewPoint("syslog", map[string]string{
			"appname":  appname,
			"facility": "console",
			"host":     host,
			"hostname": hostname,
			"severity": severity,
		}, map[string]interface{}{
			"facility_code": 14,
			"message":       string(l.buf),
			"procid":        "0",
			"severity_code": severityCode,
			"timestamp":     now.Unix(),
			"version":       1,
		}, now)

		if err != nil {
			Printf("Error make point to save logs into influx : %s", err)
		}

		bp.AddPoint(pt)

		if err := l.cInflux.Write(bp); err != nil {
			Printf("Error inserting logs to influx : %s", err)
		}
	}

	_, err := l.out.Write(l.buf)
	return err
}

// Printf calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Printf.
func (l *CustomLogger) Printf(format string, v ...interface{}) {
	l.Output(2, fmt.Sprintf(format, v...))
}

// Print calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Print.
func (l *CustomLogger) Print(v ...interface{}) { l.Output(2, fmt.Sprint(v...)) }

// Println calls l.Output to print to the logger.
// Arguments are handled in the manner of fmt.Println.
func (l *CustomLogger) Println(v ...interface{}) { l.Output(2, fmt.Sprintln(v...)) }

// Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
func (l *CustomLogger) Fatal(v ...interface{}) {
	l.Output(2, fmt.Sprint(v...))
	os.Exit(1)
}

// Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
func (l *CustomLogger) Fatalf(format string, v ...interface{}) {
	l.Output(2, fmt.Sprintf(format, v...))
	os.Exit(1)
}

// Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
func (l *CustomLogger) Fatalln(v ...interface{}) {
	l.Output(2, fmt.Sprintln(v...))
	os.Exit(1)
}

// Panic is equivalent to l.Print() followed by a call to panic().
func (l *CustomLogger) Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	l.Output(2, s)
	panic(s)
}

// Panicf is equivalent to l.Printf() followed by a call to panic().
func (l *CustomLogger) Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	l.Output(2, s)
	panic(s)
}

// Panicln is equivalent to l.Println() followed by a call to panic().
func (l *CustomLogger) Panicln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	l.Output(2, s)
	panic(s)
}

// Flags returns the output flags for the logger.
func (l *CustomLogger) Flags() int {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.flag
}

// SetFlags sets the output flags for the logger.
func (l *CustomLogger) SetFlags(flag int) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.flag = flag
}

// Prefix returns the output prefix for the logger.
func (l *CustomLogger) Prefix() string {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.prefix
}

// SetPrefix sets the output prefix for the logger.
func (l *CustomLogger) SetPrefix(prefix string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.prefix = prefix
}

// Writer returns the output destination for the logger.
func (l *CustomLogger) Writer() io.Writer {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.out
}

// SetOutput sets the output destination for the standard logger.
func SetOutput(w io.Writer) {
	std.mu.Lock()
	defer std.mu.Unlock()
	std.out = w
}

// Flags returns the output flags for the standard logger.
func Flags() int {
	return std.Flags()
}

// SetFlags sets the output flags for the standard logger.
func SetFlags(flag int) {
	std.SetFlags(flag)
}

// Prefix returns the output prefix for the standard logger.
func Prefix() string {
	return std.Prefix()
}

// SetPrefix sets the output prefix for the standard logger.
func SetPrefix(prefix string) {
	std.SetPrefix(prefix)
}

// Writer returns the output destination for the standard logger.
func Writer() io.Writer {
	return std.Writer()
}

// These functions write to the standard logger.

// Print calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Print.
func Print(v ...interface{}) {
	std.Output(2, fmt.Sprint(v...))
}

// Printf calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Printf.
func Printf(format string, v ...interface{}) {
	std.Output(2, fmt.Sprintf(format, v...))
}

// Println calls Output to print to the standard logger.
// Arguments are handled in the manner of fmt.Println.
func Println(v ...interface{}) {
	std.Output(2, fmt.Sprintln(v...))
}

// Fatal is equivalent to Print() followed by a call to os.Exit(1).
func Fatal(v ...interface{}) {
	std.Output(2, fmt.Sprint(v...))
	os.Exit(1)
}

// Fatalf is equivalent to Printf() followed by a call to os.Exit(1).
func Fatalf(format string, v ...interface{}) {
	std.Output(2, fmt.Sprintf(format, v...))
	os.Exit(1)
}

// Fatalln is equivalent to Println() followed by a call to os.Exit(1).
func Fatalln(v ...interface{}) {
	std.Output(2, fmt.Sprintln(v...))
	os.Exit(1)
}

// Panic is equivalent to Print() followed by a call to panic().
func Panic(v ...interface{}) {
	s := fmt.Sprint(v...)
	std.Output(2, s)
	panic(s)
}

// Panicf is equivalent to Printf() followed by a call to panic().
func Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(format, v...)
	std.Output(2, s)
	panic(s)
}

// Panicln is equivalent to Println() followed by a call to panic().
func Panicln(v ...interface{}) {
	s := fmt.Sprintln(v...)
	std.Output(2, s)
	panic(s)
}

// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is the count of the number of
// frames to skip when computing the file name and line number
// if Llongfile or Lshortfile is set; a value of 1 will print the details
// for the caller of Output.
func Output(calldepth int, s string) error {
	return std.Output(calldepth+1, s) // +1 for this frame.
}
